(self["webpackChunkweb"] = self["webpackChunkweb"] || []).push([["FatalErrorPage"],{

/***/ "./src/pages/FatalErrorPage/FatalErrorPage.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("../node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__("../node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__("../node_modules/react-refresh/runtime.js");


// This page will be rendered when an error makes it all the way to the top of the
// application without being handled by a Javascript catch statement or React error
// boundary.
//
// You can modify this page as you wish, but it is important to keep things simple to
// avoid the possibility that it will cause its own error. If it does, Redwood will
// still render a generic error page, but your users will prefer something a bit more
// thoughtful. =)

// Ensures that production builds do not include the error page
var RedwoodDevFatalErrorPage = undefined;
if (true) {
  RedwoodDevFatalErrorPage = (__webpack_require__("../node_modules/@redwoodjs/web/dist/components/DevFatalErrorPage.js").DevFatalErrorPage);
}
/* harmony default export */ __webpack_exports__["default"] = (RedwoodDevFatalErrorPage || function () {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("main", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("style", {
    dangerouslySetInnerHTML: {
      __html: "\n              html, body {\n                margin: 0;\n              }\n              html * {\n                box-sizing: border-box;\n              }\n              main {\n                display: flex;\n                align-items: center;\n                font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", sans-serif;\n                text-align: center;\n                background-color: #E2E8F0;\n                height: 100vh;\n              }\n              section {\n                background-color: white;\n                border-radius: 0.25rem;\n                width: 32rem;\n                padding: 1rem;\n                margin: 0 auto;\n                box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n              }\n              h1 {\n                font-size: 2rem;\n                margin: 0;\n                font-weight: 500;\n                line-height: 1;\n                color: #2D3748;\n              }\n            "
    }
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("section", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h1", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement("span", null, "Something went wrong"))));
});

var $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
var $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		var errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		var testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "../node_modules/@redwoodjs/web/dist/components/DevFatalErrorPage.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/object/define-property.js");
var _interopRequireWildcard = (__webpack_require__("../node_modules/@babel/runtime-corejs3/helpers/interopRequireWildcard.js")["default"]);
var _interopRequireDefault = (__webpack_require__("../node_modules/@babel/runtime-corejs3/helpers/interopRequireDefault.js")["default"]);
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.DevFatalErrorPage = void 0;
var _map = _interopRequireDefault(__webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/instance/map.js"));
var _includes = _interopRequireDefault(__webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/instance/includes.js"));
var _slice = _interopRequireDefault(__webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/instance/slice.js"));
var _filter = _interopRequireDefault(__webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/instance/filter.js"));
var _padStart = _interopRequireDefault(__webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/instance/pad-start.js"));
var _stringify = _interopRequireDefault(__webpack_require__("../node_modules/@babel/runtime-corejs3/core-js/json/stringify.js"));
var _react = _interopRequireWildcard(__webpack_require__("../node_modules/react/index.js"));
var _stacktracey = _interopRequireDefault(__webpack_require__("../node_modules/stacktracey/stacktracey.js"));
// This file is a hard fork of panic-overlay for RedwoodJS. The original code
// is licensed under The Unlicense - https://github.com/xpl/panic-overlay/blob/master/LICENSE
// making it fine for embedding inside this project.

// Stacktracey requires buffer, which Vite does not polyfill by default
window.Buffer = window.Buffer || (__webpack_require__("../node_modules/buffer/index.js").Buffer);
// RWJS_SRC_ROOT is defined and defaulted in webpack to the base path
const srcRoot = {"RWJS_SRC_ROOT":"/home/aaron/Desktop/Redwood Expanion/Expansion"}?.RWJS_SRC_ROOT || '';
let appRoot;
if (/^[A-Z]:\\/.test(srcRoot)) {
  // On Windows srcRoot will be something like C:\Users\bob\dev\rwApp
  appRoot = srcRoot.substring(3).replace(/\\/g, '/');
} else {
  // On Linux/MacOS srcRoot will be something like /Users/bob/dev/rwApp
  appRoot = srcRoot.substring(1);
}

// Allow APIs client to attach response/request

const DevFatalErrorPage = props => {
  var _context;
  // Safety fallback
  if (!props.error) {
    return /*#__PURE__*/_react.default.createElement("h3", null, "Could not render the error page due to a missing error, please see the console for more details.");
  }
  const err = props.error;
  const stack = new _stacktracey.default(err).withSources();
  const typeName = String(err['type'] || err.constructor && err.constructor.name || typeof err);
  const msg = String(err && err.message);
  const FileRef = stack.items[0] ? /*#__PURE__*/_react.default.createElement("a", {
    href: toVSCodeURL(stack.items[0])
  }, stack.items[0].fileName) : null;
  return /*#__PURE__*/_react.default.createElement("main", {
    className: "error-page"
  }, /*#__PURE__*/_react.default.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: css
    }
  }), /*#__PURE__*/_react.default.createElement("nav", null, /*#__PURE__*/_react.default.createElement("h1", null, "A fatal runtime error occurred when rendering ", FileRef), /*#__PURE__*/_react.default.createElement("div", null, "Get help via ", /*#__PURE__*/_react.default.createElement(Discord, null), " or ", /*#__PURE__*/_react.default.createElement(Discourse, null))), /*#__PURE__*/_react.default.createElement("section", {
    className: "panic-overlay"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "error"
  }, /*#__PURE__*/_react.default.createElement("h3", {
    className: "error-title"
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "error-type"
  }, typeName), /*#__PURE__*/_react.default.createElement("span", {
    className: "error-message"
  }, prettyMessage(msg))), /*#__PURE__*/_react.default.createElement("div", {
    className: "error-stack"
  }, (0, _map.default)(_context = stack.items).call(_context, (entry, i) => /*#__PURE__*/_react.default.createElement(StackEntry, {
    key: i,
    entry: entry,
    i: i,
    message: msg
  })))), props.error.mostRecentRequest ? /*#__PURE__*/_react.default.createElement(ResponseRequest, {
    error: props.error
  }) : null));
};
exports.DevFatalErrorPage = DevFatalErrorPage;
function hideStackLine(fileReference) {
  return fileReference.length === 1 || (0, _includes.default)(fileReference).call(fileReference, 'node_modules/react-dom');
}
function StackEntry(_ref) {
  var _context2, _context3;
  let {
    entry,
    i
  } = _ref;
  const {
    sourceFile = {
      lines: []
    },
    line,
    column,
    fileShort
  } = entry;
  const lineIndex = (line || 0) - 1;
  const maxLines = sourceFile.lines.length;
  const window = 4;
  let start = lineIndex - window,
    end = lineIndex + window + 2;
  if (start < 0) {
    end = Math.min(end - start, maxLines);
    start = 0;
  }
  if (end > maxLines) {
    start = Math.max(0, start - (end - maxLines));
    end = maxLines;
  }
  const lines = (0, _slice.default)(_context2 = sourceFile.lines).call(_context2, start, end);
  const lineNumberWidth = String(start + lines.length).length;
  const highlightIndex = (line || 0) - start - 1;
  const onLastLine = highlightIndex === lines.length - 1;
  const shortestPath = path => path.replace(appRoot || '', '');
  const expanded = !shouldHideEntry(entry, i);
  const clickable = lines.length;
  const LinkToVSCode = props => clickable ? /*#__PURE__*/_react.default.createElement("a", {
    href: toVSCodeURL(entry)
  }, props.children) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, props.children);
  const fileReference = !lines.length ? '[System]' : shortestPath(fileShort);
  const rootClasses = (0, _filter.default)(_context3 = ['stack-entry', !(0, _includes.default)(fileReference).call(fileReference, 'node_modules') && 'rwfw', i === 0 && ' first', lines.length && 'clickable']).call(_context3, Boolean);
  return hideStackLine(fileReference) ? /*#__PURE__*/_react.default.createElement("div", null) : /*#__PURE__*/_react.default.createElement(LinkToVSCode, null, /*#__PURE__*/_react.default.createElement("div", {
    className: rootClasses.join(' ')
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "file"
  }, fileReference + ' in ' + entry.callee), expanded && !!lines.length && /*#__PURE__*/_react.default.createElement("div", {
    className: 'lines' + (onLastLine ? '.no-fade' : '')
  }, (0, _map.default)(lines).call(lines, (text, i) => {
    var _context4;
    return /*#__PURE__*/_react.default.createElement("div", {
      key: i,
      className: 'line' + (i === highlightIndex ? ' line-hili' : '')
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "line-number"
    }, (0, _padStart.default)(_context4 = String(start + i + 1)).call(_context4, lineNumberWidth, ' ')), /*#__PURE__*/_react.default.createElement("span", {
      className: "line-text"
    }, i === highlightIndex ? renderHighlightedLine(text, column || 0) : text));
  }))));
  function renderHighlightedLine(text, column) {
    const [before, after] = [(0, _slice.default)(text).call(text, 0, column - 1), (0, _slice.default)(text).call(text, column - 1)];
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, before, /*#__PURE__*/_react.default.createElement("strong", null, after));
  }
  function shouldHideEntry(entry, i) {
    var _context5;
    return (entry.thirdParty || entry['native'] || entry.hide || (0, _includes.default)(_context5 = entry.fileShort).call(_context5, 'node_modules')) && i !== 0;
  }
}
function toVSCodeURL(entry) {
  // To account for folks using vscode-insiders etc
  // This is defined by webpack and vite from .env
  const scheme = {"RWJS_SRC_ROOT":"/home/aaron/Desktop/Redwood Expanion/Expansion"}.REDWOOD_ENV_EDITOR || 'vscode';
  return `${scheme}://file/${entry.fileShort}:${entry.line}:${entry.column}`;
}
function prettyMessage(msg) {
  // This could slowly get build out with more cases for improving whitespace/readability
  // over time. There's probably a function like this in react-error-overlay
  return msg.replace('is not a function.', 'is not a function.\n\n');
}
function ResponseRequest(props) {
  const [openQuery, setOpenQuery] = (0, _react.useState)(false);
  const [openResponse, setOpenResponse] = (0, _react.useState)(false);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "request-response"
  }, props.error.mostRecentRequest ? /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h4", null, "Request: ", props.error.mostRecentRequest.operationName), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h5", null, "Variables:"), /*#__PURE__*/_react.default.createElement("code", null, /*#__PURE__*/_react.default.createElement("pre", null, (0, _stringify.default)(props.error.mostRecentRequest.variables, null, '  ')))), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h5", null, "Query:"), /*#__PURE__*/_react.default.createElement("code", null, /*#__PURE__*/_react.default.createElement("pre", {
    onClick: () => setOpenQuery(!openQuery),
    className: openQuery ? 'open' : 'preview'
  }, props.error.mostRecentRequest.query)))) : null, props.error.mostRecentRequest ? /*#__PURE__*/_react.default.createElement("div", {
    className: "response"
  }, /*#__PURE__*/_react.default.createElement("h4", null, "Response"), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h5", null, "JSON:"), /*#__PURE__*/_react.default.createElement("code", null, /*#__PURE__*/_react.default.createElement("pre", {
    onClick: () => setOpenResponse(!openResponse),
    className: openResponse ? 'open' : 'preview'
  }, (0, _stringify.default)(props.error.mostRecentResponse, null, '  '))))) : null);
}
const css = `
body {
  background-color: rgb(253, 248, 246) !important;
  font-family: "Open Sans", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif  !important;
}

.panic-overlay {
  background-color: white;
  padding: 0 2.5em;
}

.panic-overlay strong {
  font-weight: bold;
}

main.error-page nav {
  display: flex;
  flex-direction: row;
  align: center;
  justify-content: space-between;
  padding: 1em 2.5em;
}

main.error-page  nav h1 {
  color: black;
  margin: 0;
  padding: 0;
  font-size: 1.2em;
  font-weight: 400;
  opacity: 1;
  color: rgb(191, 71, 34);
}

main.error-page nav h1 a {
  color: black;
  text-decoration: underline;
}

main.error-page nav div {
  display: flex;
  align-items: center;
  line-height: 2em;
}

main.error-page nav div a {
  display: flex;
  margin: 0 0.3em;
}

main.error-page nav svg {
  width: 24px;
  height: 24px;
  fill: rgb(191, 71, 34);
}

main.error-page nav svg.discourse {
  height: 20px;
  width: 20px;
}

main.error-page nav svg:hover {
  fill: rgb(200, 32, 32);
}

.request-response div div code,
.request-response div div pre {
  background-color: transparent !important;
}

.panic-overlay a {
  text-decoration: none;
}

.panic-overlay .error {
  padding: 3em 0;
}

.panic-overlay .error-title {
  display: flex;
  align-items: stretch;
}

.panic-overlay .error-type {
  min-height: 2.8em;
  display: flex !important;
  align-items: center;
  padding: 0 1em;
  background: rgb(195, 74, 37);
  color: white;
  margin-right: 2em;
  white-space: nowrap;
  text-align: center;
}
.panic-overlay .error-counter {
  color: white;
  opacity: 0.3;
  position: absolute;
  left: 0.8em;
}
.panic-overlay .error-message {
  display: flex !important;
  align-items: center;
  font-weight: 300;
  line-height: 1.1em;
  font-size: 2.8em;
  word-break: break-all;
  white-space: pre-wrap;
}
.panic-overlay .error-stack {
  margin-top: 2em;
  white-space: pre;
  padding-left: var(--left-pad);
}

.panic-overlay .stack-entry.clickable {
  cursor: pointer;
}

.panic-overlay .stack-entry {
  margin-left: 2.5em;
}

.panic-overlay .stack-entry.rwfw {
  font-weight: bold;
}

.panic-overlay .stack-entry .file {
  color: rgb(195, 74, 37, 0.8);
}

.panic-overlay .stack-entry.first .file {
  font-weight: bold;
  color: rgb(200, 47, 47);
}

.panic-overlay .file strong {
  font-weight: normal;
}
.panic-overlay .file:before,
.panic-overlay .more:before {
  content: "@ ";
  opacity: 0.5;
  margin-left: -1.25em;
}
.panic-overlay .more:before {
  content: "▷ ";
  opacity: 0.5;
}
.panic-overlay .more {
  opacity: 0.25;
  color: black;
  font-size: 0.835em;
  cursor: pointer;
  text-align: center;
  display: none;
}
.panic-overlay .more em {
  font-style: normal;
  font-weight: normal;
  border-bottom: 1px dashed black;
}
.panic-overlay .collapsed .panic-overlay .more {
  display: block;
}
.panic-overlay .lines, .request-response code {
  color: rgb(187, 165, 165);
  font-size: 0.835em;
  margin-bottom: 2.5em;
  padding: 2rem;
  font-family: Menlo, Monaco, "Courier New", Courier, monospace;
}
.panic-overlay .lines:not(.panic-overlay .no-fade) {
  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
}
.panic-overlay .line-number {
  padding-right: 1.5em;
  opacity: 0.5;
}
.panic-overlay .line-hili {
  background: rgb(253, 248, 246);
  color: #5f4545;
}
.panic-overlay .stack-entry:first-child .panic-overlay .line-hili strong {
  text-decoration: underline wavy #ff0040;
}
.panic-overlay .line-hili em {
  font-style: italic;
  color: rgb(195, 74, 37);
  font-size: 0.75em;
  margin-left: 2em;
  opacity: 0.25;
  position: relative;
  top: -0.115em;
  white-space: nowrap;
}
.panic-overlay .line-hili em:before {
  content: "← ";
}
.panic-overlay .no-source {
  font-style: italic;
}

.panic-overlay .request-response {
  margin-top: 2rem;
  display: flex;
  flex-direction: row;
}

.panic-overlay .request-response > div {
  flex: 1;
}

.panic-overlay .request-response .response {
  margin-left: 2rem;
}

.panic-overlay .request-response h4 {
  background-color: rgb(195, 74, 37);
  color: white;
  font-size: 1.5rem;
  padding: 0.2rem 1rem;
}

.panic-overlay .request-response > div > div {
  margin: 1rem 1rem;
}

.panic-overlay .request-response pre {
  background-color: rgb(253, 248, 246);
  padding: 1rem 1rem;
  color: black;
}

.panic-overlay .request-response pre.open {
  max-height: auto;
}

.panic-overlay .request-response pre.preview {
  max-height: 13.5rem;
  overflow-y: auto;

  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 1) 75%, rgba(0, 0, 0, 0));
}

@media only screen and (max-width: 640px) {
  .panic-overlay {
    font-size: 15px;
  }

  .panic-overlay h1 {
    margin: 40px 0;
  }
}
@media only screen and (max-width: 500px) {
  .panic-overlay {
    font-size: 14px;
  }

  .panic-overlay h1 {
    margin: 30px 0;
  }
}
`;
const Discourse = () => /*#__PURE__*/_react.default.createElement("a", {
  href: "https://community.redwoodjs.com",
  title: "Go to Redwood's Discourse server"
}, /*#__PURE__*/_react.default.createElement("svg", {
  className: "discourse",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 32 32"
}, /*#__PURE__*/_react.default.createElement("path", {
  d: "M16.1357143,0 C7.37857143,0 0,7.03571429 0,15.7214286 C0,16 0.00714285714,32 0.00714285714,32 L16.1357143,31.9857143 C24.9,31.9857143 32,24.6785714 32,15.9928571 C32,7.30714286 24.9,0 16.1357143,0 Z M16,25.1428571 C14.6142857,25.1428571 13.2928571,24.8357143 12.1142857,24.2785714 L6.32142857,25.7142857 L7.95714286,20.3571429 C7.25714286,19.0642857 6.85714286,17.5785714 6.85714286,16 C6.85714286,10.95 10.95,6.85714286 16,6.85714286 C21.05,6.85714286 25.1428571,10.95 25.1428571,16 C25.1428571,21.05 21.05,25.1428571 16,25.1428571 Z"
})));
const Discord = () => /*#__PURE__*/_react.default.createElement("a", {
  href: "https://discord.gg/redwoodjs",
  title: "Go to Redwood's Discord server"
}, /*#__PURE__*/_react.default.createElement("svg", {
  viewBox: "0 0 36 36",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/_react.default.createElement("path", {
  d: "M29.9699 7.7544C27.1043 5.44752 22.5705 5.05656 22.3761 5.04288C22.2284 5.03072 22.0806 5.0648 21.9531 5.1404C21.8257 5.216 21.7249 5.32937 21.6647 5.4648C21.5783 5.65936 21.5049 5.85949 21.4451 6.06384C23.3409 6.38424 25.6694 7.02864 27.7761 8.33616C27.8565 8.38604 27.9262 8.45126 27.9814 8.52809C28.0366 8.60493 28.0761 8.69187 28.0976 8.78397C28.1192 8.87607 28.1224 8.97151 28.1071 9.06485C28.0917 9.15819 28.0582 9.24759 28.0083 9.32796C27.9584 9.40833 27.8932 9.47809 27.8164 9.53325C27.7395 9.58842 27.6526 9.62791 27.5605 9.64947C27.4684 9.67103 27.373 9.67424 27.2796 9.65892C27.1863 9.6436 27.0969 9.61004 27.0165 9.56016C23.3949 7.3116 18.8719 7.2 17.9999 7.2C17.1287 7.2 12.6028 7.31232 8.98338 9.55944C8.90301 9.60932 8.81361 9.64288 8.72027 9.6582C8.62693 9.67352 8.53149 9.67031 8.43939 9.64875C8.25339 9.6052 8.09231 9.48955 7.99158 9.32724C7.89085 9.16493 7.85873 8.96925 7.90227 8.78325C7.94582 8.59725 8.06147 8.43617 8.22378 8.33544C10.3305 7.03152 12.659 6.38424 14.5547 6.06672C14.4453 5.7096 14.3459 5.48424 14.3387 5.4648C14.2788 5.32841 14.1776 5.2143 14.0493 5.13859C13.921 5.06288 13.7721 5.0294 13.6238 5.04288C13.4294 5.05728 8.89554 5.44752 5.99034 7.78536C4.47474 9.18792 1.43994 17.3894 1.43994 24.48C1.43994 24.6067 1.47378 24.7277 1.5357 24.8371C3.62802 28.5163 9.3405 29.4775 10.6423 29.52H10.6646C10.7782 29.5203 10.8903 29.4937 10.9916 29.4424C11.093 29.3911 11.1808 29.3165 11.2478 29.2248L12.5632 27.4133C9.01146 26.4967 7.19706 24.9386 7.09338 24.8458C6.95017 24.7194 6.86303 24.5412 6.85115 24.3506C6.83927 24.1599 6.90361 23.9723 7.03002 23.8291C7.15643 23.6859 7.33456 23.5988 7.52522 23.5869C7.71588 23.575 7.90345 23.6394 8.04666 23.7658C8.08842 23.8054 11.4299 26.64 17.9999 26.64C24.5807 26.64 27.9223 23.7938 27.9561 23.7658C28.0998 23.6403 28.2874 23.5769 28.4777 23.5896C28.668 23.6023 28.8456 23.69 28.9713 23.8334C29.0335 23.9042 29.0812 23.9864 29.1117 24.0756C29.1421 24.1647 29.1546 24.259 29.1486 24.353C29.1426 24.447 29.1181 24.5389 29.0766 24.6235C29.035 24.708 28.9772 24.7836 28.9065 24.8458C28.8028 24.9386 26.9884 26.4967 23.4367 27.4133L24.7528 29.2248C24.8198 29.3164 24.9074 29.3909 25.0087 29.4422C25.1099 29.4935 25.2218 29.5202 25.3353 29.52H25.3569C26.6601 29.4775 32.3719 28.5156 34.4649 24.8371C34.5261 24.7277 34.5599 24.6067 34.5599 24.48C34.5599 17.3894 31.5251 9.18864 29.9699 7.7544V7.7544ZM13.3199 21.6C11.9275 21.6 10.7999 20.3112 10.7999 18.72C10.7999 17.1288 11.9275 15.84 13.3199 15.84C14.7124 15.84 15.8399 17.1288 15.8399 18.72C15.8399 20.3112 14.7124 21.6 13.3199 21.6ZM22.6799 21.6C21.2875 21.6 20.1599 20.3112 20.1599 18.72C20.1599 17.1288 21.2875 15.84 22.6799 15.84C24.0724 15.84 25.1999 17.1288 25.1999 18.72C25.1999 20.3112 24.0724 21.6 22.6799 21.6Z"
})));

/***/ }),

/***/ "../node_modules/as-table/build/as-table.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const O = Object;

var _require = __webpack_require__("../node_modules/printable-characters/build/printable-characters.js");

const first = _require.first,
      strlen = _require.strlen,
      limit = (s, n) => first(s, n - 1) + '…';

const asColumns = (rows, cfg_) => {

    const zip = (arrs, f) => arrs.reduce((a, b) => b.map((b, i) => [].concat(_toConsumableArray(a[i] || []), [b])), []).map(args => f.apply(undefined, _toConsumableArray(args))),


    /*  Convert cell data to string (converting multiline text to singleline) */

    cells = rows.map(r => r.map(c => c.replace(/\n/g, '\\n'))),


    /*  Compute column widths (per row) and max widths (per column)     */

    cellWidths = cells.map(r => r.map(strlen)),
          maxWidths = zip(cellWidths, Math.max),


    /*  Default config     */

    cfg = O.assign({
        delimiter: '  ',
        minColumnWidths: maxWidths.map(x => 0),
        maxTotalWidth: 0 }, cfg_),
          delimiterLength = strlen(cfg.delimiter),


    /*  Project desired column widths, taking maxTotalWidth and minColumnWidths in account.     */

    totalWidth = maxWidths.reduce((a, b) => a + b, 0),
          relativeWidths = maxWidths.map(w => w / totalWidth),
          maxTotalWidth = cfg.maxTotalWidth - delimiterLength * (maxWidths.length - 1),
          excessWidth = Math.max(0, totalWidth - maxTotalWidth),
          computedWidths = zip([cfg.minColumnWidths, maxWidths, relativeWidths], (min, max, relative) => Math.max(min, Math.floor(max - excessWidth * relative))),


    /*  This is how many symbols we should pad or cut (per column).  */

    restCellWidths = cellWidths.map(widths => zip([computedWidths, widths], (a, b) => a - b));

    /*  Perform final composition.   */

    return zip([cells, restCellWidths], (a, b) => zip([a, b], (str, w) => w >= 0 ? cfg.right ? ' '.repeat(w) + str : str + ' '.repeat(w) : limit(str, strlen(str) + w)).join(cfg.delimiter));
};

const asTable = cfg => O.assign(arr => {
    var _ref;

    /*  Print arrays  */

    if (arr[0] && Array.isArray(arr[0])) {
        return asColumns(arr.map(r => r.map((c, i) => c === undefined ? '' : cfg.print(c, i))), cfg).join('\n');
    }

    /*  Print objects   */

    const colNames = [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, _toConsumableArray(arr.map(O.keys)))))),
          columns = [colNames.map(cfg.title)].concat(_toConsumableArray(arr.map(o => colNames.map(key => o[key] === undefined ? '' : cfg.print(o[key], key))))),
          lines = asColumns(columns, cfg);

    return (cfg.dash ? [lines[0], cfg.dash.repeat(strlen(lines[0]))].concat(_toConsumableArray(lines.slice(1))) : lines).join('\n');
}, cfg, {

    configure: newConfig => asTable(O.assign({}, cfg, newConfig))
});

module.exports = asTable({

    maxTotalWidth: Number.MAX_SAFE_INTEGER,
    print: String,
    title: String,
    dash: '-',
    right: false
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2FzLXRhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRU0sVUFBSSxNQUFKOztlQUNvQixRQUFTLHNCQUFULEM7O01BQWxCLEssWUFBQSxLO01BQU8sTSxZQUFBLE07TUFDVCxLLEdBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixLQUFXLE1BQU8sQ0FBUCxFQUFVLElBQUksQ0FBZCxJQUFtQixHOztBQUU1QyxNQUFNLFlBQVksQ0FBQyxJQUFELEVBQU8sSUFBUCxLQUFnQjs7QUFFOUIsVUFFSSxNQUFNLENBQUMsSUFBRCxFQUFPLENBQVAsS0FBYSxLQUFLLE1BQUwsQ0FBYSxDQUFDLENBQUQsRUFBSSxDQUFKLEtBQVUsRUFBRSxHQUFGLENBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixrQ0FBYyxFQUFFLENBQUYsS0FBUSxFQUF0QixJQUEwQixDQUExQixFQUFQLENBQXZCLEVBQTZELEVBQTdELEVBQWlFLEdBQWpFLENBQXNFLFFBQVEsc0NBQU0sSUFBTixFQUE5RSxDQUZ2Qjs7O0FBSUE7O0FBRUksWUFBa0IsS0FBSyxHQUFMLENBQVUsS0FBSyxFQUFFLEdBQUYsQ0FBTyxLQUFLLEVBQUUsT0FBRixDQUFXLEtBQVgsRUFBa0IsS0FBbEIsQ0FBWixDQUFmLENBTnRCOzs7QUFRQTs7QUFFSSxpQkFBa0IsTUFBTSxHQUFOLENBQVcsS0FBSyxFQUFFLEdBQUYsQ0FBTyxNQUFQLENBQWhCLENBVnRCO0FBQUEsVUFXSSxZQUFrQixJQUFLLFVBQUwsRUFBaUIsS0FBSyxHQUF0QixDQVh0Qjs7O0FBYUE7O0FBRUksVUFBa0IsRUFBRSxNQUFGLENBQVU7QUFDUixtQkFBVyxJQURIO0FBRVIseUJBQWlCLFVBQVUsR0FBVixDQUFlLEtBQUssQ0FBcEIsQ0FGVDtBQUdSLHVCQUFlLENBSFAsRUFBVixFQUdzQixJQUh0QixDQWZ0QjtBQUFBLFVBb0JJLGtCQUFrQixPQUFRLElBQUksU0FBWixDQXBCdEI7OztBQXNCQTs7QUFFSSxpQkFBa0IsVUFBVSxNQUFWLENBQWtCLENBQUMsQ0FBRCxFQUFJLENBQUosS0FBVSxJQUFJLENBQWhDLEVBQW1DLENBQW5DLENBeEJ0QjtBQUFBLFVBeUJJLGlCQUFrQixVQUFVLEdBQVYsQ0FBZSxLQUFLLElBQUksVUFBeEIsQ0F6QnRCO0FBQUEsVUEwQkksZ0JBQWtCLElBQUksYUFBSixHQUFxQixtQkFBbUIsVUFBVSxNQUFWLEdBQW1CLENBQXRDLENBMUIzQztBQUFBLFVBMkJJLGNBQWtCLEtBQUssR0FBTCxDQUFVLENBQVYsRUFBYSxhQUFhLGFBQTFCLENBM0J0QjtBQUFBLFVBNEJJLGlCQUFrQixJQUFLLENBQUMsSUFBSSxlQUFMLEVBQXNCLFNBQXRCLEVBQWlDLGNBQWpDLENBQUwsRUFDRSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsUUFBWCxLQUF3QixLQUFLLEdBQUwsQ0FBVSxHQUFWLEVBQWUsS0FBSyxLQUFMLENBQVksTUFBTSxjQUFjLFFBQWhDLENBQWYsQ0FEMUIsQ0E1QnRCOzs7QUErQkE7O0FBRUkscUJBQWtCLFdBQVcsR0FBWCxDQUFnQixVQUFVLElBQUssQ0FBQyxjQUFELEVBQWlCLE1BQWpCLENBQUwsRUFBK0IsQ0FBQyxDQUFELEVBQUksQ0FBSixLQUFVLElBQUksQ0FBN0MsQ0FBMUIsQ0FqQ3RCOztBQW1DQTs7QUFFSSxXQUFPLElBQUssQ0FBQyxLQUFELEVBQVEsY0FBUixDQUFMLEVBQThCLENBQUMsQ0FBRCxFQUFJLENBQUosS0FDN0IsSUFBSyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQUwsRUFBYSxDQUFDLEdBQUQsRUFBTSxDQUFOLEtBQWEsS0FBSyxDQUFOLEdBQ00sSUFBSSxLQUFKLEdBQWEsSUFBSSxNQUFKLENBQVksQ0FBWixJQUFpQixHQUE5QixHQUFzQyxNQUFNLElBQUksTUFBSixDQUFZLENBQVosQ0FEbEQsR0FFTSxNQUFPLEdBQVAsRUFBWSxPQUFRLEdBQVIsSUFBZSxDQUEzQixDQUYvQixFQUUrRCxJQUYvRCxDQUVxRSxJQUFJLFNBRnpFLENBREQsQ0FBUDtBQUlQLENBM0NEOztBQTZDQSxNQUFNLFVBQVUsT0FBTyxFQUFFLE1BQUYsQ0FBVSxPQUFPO0FBQUE7O0FBRXhDOztBQUVJLFFBQUksSUFBSSxDQUFKLEtBQVUsTUFBTSxPQUFOLENBQWUsSUFBSSxDQUFKLENBQWYsQ0FBZCxFQUFzQztBQUNsQyxlQUFPLFVBQVcsSUFBSSxHQUFKLENBQVMsS0FBSyxFQUFFLEdBQUYsQ0FDUSxDQUFDLENBQUQsRUFBSSxDQUFKLEtBQVcsTUFBTSxTQUFQLEdBQW9CLEVBQXBCLEdBQXlCLElBQUksS0FBSixDQUFXLENBQVgsRUFBYyxDQUFkLENBRDNDLENBQWQsQ0FBWCxFQUlXLEdBSlgsRUFJZ0IsSUFKaEIsQ0FJc0IsSUFKdEIsQ0FBUDtBQUtIOztBQUVMOztBQUVJLFVBQU0sd0NBQWUsSUFBSSxHQUFKLENBQVMsWUFBRyxNQUFILGdDQUFjLElBQUksR0FBSixDQUFTLEVBQUUsSUFBWCxDQUFkLEVBQVQsQ0FBZixFQUFOO0FBQUEsVUFDTSxXQUFZLFNBQVMsR0FBVCxDQUFjLElBQUksS0FBbEIsQ0FBWiw0QkFDZSxJQUFJLEdBQUosQ0FBUyxLQUFLLFNBQVMsR0FBVCxDQUNJLE9BQVEsRUFBRSxHQUFGLE1BQVcsU0FBWixHQUF5QixFQUF6QixHQUE4QixJQUFJLEtBQUosQ0FBVyxFQUFFLEdBQUYsQ0FBWCxFQUFtQixHQUFuQixDQUR6QyxDQUFkLENBRGYsRUFETjtBQUFBLFVBT00sUUFBVyxVQUFXLE9BQVgsRUFBb0IsR0FBcEIsQ0FQakI7O0FBU0EsV0FBTyxDQUFDLElBQUksSUFBSixJQUFZLE1BQU0sQ0FBTixDQUFaLEVBQXNCLElBQUksSUFBSixDQUFTLE1BQVQsQ0FBaUIsT0FBUSxNQUFNLENBQU4sQ0FBUixDQUFqQixDQUF0Qiw0QkFBOEQsTUFBTSxLQUFOLENBQWEsQ0FBYixDQUE5RCxLQUFpRixLQUFsRixFQUF5RixJQUF6RixDQUErRixJQUEvRixDQUFQO0FBRUgsQ0F6QnNCLEVBeUJwQixHQXpCb0IsRUF5QmY7O0FBRUosZUFBVyxhQUFhLFFBQVMsRUFBRSxNQUFGLENBQVUsRUFBVixFQUFjLEdBQWQsRUFBbUIsU0FBbkIsQ0FBVDtBQUZwQixDQXpCZSxDQUF2Qjs7QUE4QkEsT0FBTyxPQUFQLEdBQWlCLFFBQVM7O0FBRXRCLG1CQUFlLE9BQU8sZ0JBRkE7QUFHdEIsV0FBTyxNQUhlO0FBSXRCLFdBQU8sTUFKZTtBQUt0QixVQUFNLEdBTGdCO0FBTXRCLFdBQU87QUFOZSxDQUFULENBQWpCIiwiZmlsZSI6ImFzLXRhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IE8gPSBPYmplY3RcbiAgICAsIHsgZmlyc3QsIHN0cmxlbiB9ID0gcmVxdWlyZSAoJ3ByaW50YWJsZS1jaGFyYWN0ZXJzJykgLy8gaGFuZGxlcyBBTlNJIGNvZGVzIGFuZCBpbnZpc2libGUgY2hhcmFjdGVyc1xuICAgICwgbGltaXQgPSAocywgbikgPT4gKGZpcnN0IChzLCBuIC0gMSkgKyAn4oCmJylcblxuY29uc3QgYXNDb2x1bW5zID0gKHJvd3MsIGNmZ18pID0+IHtcbiAgICBcbiAgICBjb25zdFxuXG4gICAgICAgIHppcCA9IChhcnJzLCBmKSA9PiBhcnJzLnJlZHVjZSAoKGEsIGIpID0+IGIubWFwICgoYiwgaSkgPT4gWy4uLmFbaV0gfHwgW10sIGJdKSwgW10pLm1hcCAoYXJncyA9PiBmICguLi5hcmdzKSksXG5cbiAgICAvKiAgQ29udmVydCBjZWxsIGRhdGEgdG8gc3RyaW5nIChjb252ZXJ0aW5nIG11bHRpbGluZSB0ZXh0IHRvIHNpbmdsZWxpbmUpICovXG5cbiAgICAgICAgY2VsbHMgICAgICAgICAgID0gcm93cy5tYXAgKHIgPT4gci5tYXAgKGMgPT4gYy5yZXBsYWNlICgvXFxuL2csICdcXFxcbicpKSksXG5cbiAgICAvKiAgQ29tcHV0ZSBjb2x1bW4gd2lkdGhzIChwZXIgcm93KSBhbmQgbWF4IHdpZHRocyAocGVyIGNvbHVtbikgICAgICovXG5cbiAgICAgICAgY2VsbFdpZHRocyAgICAgID0gY2VsbHMubWFwIChyID0+IHIubWFwIChzdHJsZW4pKSxcbiAgICAgICAgbWF4V2lkdGhzICAgICAgID0gemlwIChjZWxsV2lkdGhzLCBNYXRoLm1heCksXG5cbiAgICAvKiAgRGVmYXVsdCBjb25maWcgICAgICovXG5cbiAgICAgICAgY2ZnICAgICAgICAgICAgID0gTy5hc3NpZ24gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXI6ICcgICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29sdW1uV2lkdGhzOiBtYXhXaWR0aHMubWFwICh4ID0+IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFRvdGFsV2lkdGg6IDAgfSwgY2ZnXyksXG5cbiAgICAgICAgZGVsaW1pdGVyTGVuZ3RoID0gc3RybGVuIChjZmcuZGVsaW1pdGVyKSxcblxuICAgIC8qICBQcm9qZWN0IGRlc2lyZWQgY29sdW1uIHdpZHRocywgdGFraW5nIG1heFRvdGFsV2lkdGggYW5kIG1pbkNvbHVtbldpZHRocyBpbiBhY2NvdW50LiAgICAgKi9cblxuICAgICAgICB0b3RhbFdpZHRoICAgICAgPSBtYXhXaWR0aHMucmVkdWNlICgoYSwgYikgPT4gYSArIGIsIDApLFxuICAgICAgICByZWxhdGl2ZVdpZHRocyAgPSBtYXhXaWR0aHMubWFwICh3ID0+IHcgLyB0b3RhbFdpZHRoKSxcbiAgICAgICAgbWF4VG90YWxXaWR0aCAgID0gY2ZnLm1heFRvdGFsV2lkdGggLSAoZGVsaW1pdGVyTGVuZ3RoICogKG1heFdpZHRocy5sZW5ndGggLSAxKSksXG4gICAgICAgIGV4Y2Vzc1dpZHRoICAgICA9IE1hdGgubWF4ICgwLCB0b3RhbFdpZHRoIC0gbWF4VG90YWxXaWR0aCksXG4gICAgICAgIGNvbXB1dGVkV2lkdGhzICA9IHppcCAoW2NmZy5taW5Db2x1bW5XaWR0aHMsIG1heFdpZHRocywgcmVsYXRpdmVXaWR0aHNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtaW4sIG1heCwgcmVsYXRpdmUpID0+IE1hdGgubWF4IChtaW4sIE1hdGguZmxvb3IgKG1heCAtIGV4Y2Vzc1dpZHRoICogcmVsYXRpdmUpKSksXG5cbiAgICAvKiAgVGhpcyBpcyBob3cgbWFueSBzeW1ib2xzIHdlIHNob3VsZCBwYWQgb3IgY3V0IChwZXIgY29sdW1uKS4gICovXG5cbiAgICAgICAgcmVzdENlbGxXaWR0aHMgID0gY2VsbFdpZHRocy5tYXAgKHdpZHRocyA9PiB6aXAgKFtjb21wdXRlZFdpZHRocywgd2lkdGhzXSwgKGEsIGIpID0+IGEgLSBiKSlcblxuICAgIC8qICBQZXJmb3JtIGZpbmFsIGNvbXBvc2l0aW9uLiAgICovXG5cbiAgICAgICAgcmV0dXJuIHppcCAoW2NlbGxzLCByZXN0Q2VsbFdpZHRoc10sIChhLCBiKSA9PlxuICAgICAgICAgICAgICAgIHppcCAoW2EsIGJdLCAoc3RyLCB3KSA9PiAodyA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChjZmcucmlnaHQgPyAoJyAnLnJlcGVhdCAodykgKyBzdHIpIDogKHN0ciArICcgJy5yZXBlYXQgKHcpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAobGltaXQgKHN0ciwgc3RybGVuIChzdHIpICsgdykpKS5qb2luIChjZmcuZGVsaW1pdGVyKSlcbn1cblxuY29uc3QgYXNUYWJsZSA9IGNmZyA9PiBPLmFzc2lnbiAoYXJyID0+IHtcblxuLyogIFByaW50IGFycmF5cyAgKi9cblxuICAgIGlmIChhcnJbMF0gJiYgQXJyYXkuaXNBcnJheSAoYXJyWzBdKSkge1xuICAgICAgICByZXR1cm4gYXNDb2x1bW5zIChhcnIubWFwIChyID0+IHIubWFwIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjLCBpKSA9PiAoYyA9PT0gdW5kZWZpbmVkKSA/ICcnIDogY2ZnLnByaW50IChjLCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjZmcpLmpvaW4gKCdcXG4nKVxuICAgIH1cblxuLyogIFByaW50IG9iamVjdHMgICAqL1xuXG4gICAgY29uc3QgY29sTmFtZXMgPSBbLi4ubmV3IFNldCAoW10uY29uY2F0ICguLi5hcnIubWFwIChPLmtleXMpKSldLFxuICAgICAgICAgIGNvbHVtbnMgID0gW2NvbE5hbWVzLm1hcCAoY2ZnLnRpdGxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hcnIubWFwIChvID0+IGNvbE5hbWVzLm1hcCAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0+IChvW2tleV0gPT09IHVuZGVmaW5lZCkgPyAnJyA6IGNmZy5wcmludCAob1trZXldLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgIGxpbmVzICAgID0gYXNDb2x1bW5zIChjb2x1bW5zLCBjZmcpXG5cbiAgICByZXR1cm4gKGNmZy5kYXNoID8gW2xpbmVzWzBdLCBjZmcuZGFzaC5yZXBlYXQgKHN0cmxlbiAobGluZXNbMF0pKSwgLi4ubGluZXMuc2xpY2UgKDEpXSA6IGxpbmVzKS5qb2luICgnXFxuJylcblxufSwgY2ZnLCB7XG5cbiAgICBjb25maWd1cmU6IG5ld0NvbmZpZyA9PiBhc1RhYmxlIChPLmFzc2lnbiAoe30sIGNmZywgbmV3Q29uZmlnKSksXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzVGFibGUgKHtcblxuICAgIG1heFRvdGFsV2lkdGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIHByaW50OiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICBkYXNoOiAnLScsXG4gICAgcmlnaHQ6IGZhbHNlXG59KVxuIl19

/***/ }),

/***/ "../node_modules/base64-js/index.js":
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../node_modules/buffer/index.js":
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("../node_modules/base64-js/index.js")
var ieee754 = __webpack_require__("../node_modules/ieee754/index.js")
var isArray = __webpack_require__("../node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined
  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "../node_modules/core-js-pure/actual/instance/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__("../node_modules/core-js-pure/stable/instance/pad-start.js");

module.exports = parent;


/***/ }),

/***/ "../node_modules/core-js-pure/es/instance/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__("../node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__("../node_modules/core-js-pure/es/string/virtual/pad-start.js");

var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.padStart;
  return typeof it == 'string' || it === StringPrototype
    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.padStart) ? method : own;
};


/***/ }),

/***/ "../node_modules/core-js-pure/es/string/virtual/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__("../node_modules/core-js-pure/modules/es.string.pad-start.js");
var entryVirtual = __webpack_require__("../node_modules/core-js-pure/internals/entry-virtual.js");

module.exports = entryVirtual('String').padStart;


/***/ }),

/***/ "../node_modules/core-js-pure/features/instance/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/core-js-pure/full/instance/pad-start.js");


/***/ }),

/***/ "../node_modules/core-js-pure/full/instance/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__("../node_modules/core-js-pure/actual/instance/pad-start.js");

module.exports = parent;


/***/ }),

/***/ "../node_modules/core-js-pure/internals/string-pad-webkit-bug.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/zloirock/core-js/issues/280
var userAgent = __webpack_require__("../node_modules/core-js-pure/internals/engine-user-agent.js");

module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);


/***/ }),

/***/ "../node_modules/core-js-pure/internals/string-pad.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var uncurryThis = __webpack_require__("../node_modules/core-js-pure/internals/function-uncurry-this.js");
var toLength = __webpack_require__("../node_modules/core-js-pure/internals/to-length.js");
var toString = __webpack_require__("../node_modules/core-js-pure/internals/to-string.js");
var $repeat = __webpack_require__("../node_modules/core-js-pure/internals/string-repeat.js");
var requireObjectCoercible = __webpack_require__("../node_modules/core-js-pure/internals/require-object-coercible.js");

var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var ceil = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = toString(requireObjectCoercible($this));
    var intMaxLength = toLength(maxLength);
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : toString(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};


/***/ }),

/***/ "../node_modules/core-js-pure/internals/string-repeat.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toIntegerOrInfinity = __webpack_require__("../node_modules/core-js-pure/internals/to-integer-or-infinity.js");
var toString = __webpack_require__("../node_modules/core-js-pure/internals/to-string.js");
var requireObjectCoercible = __webpack_require__("../node_modules/core-js-pure/internals/require-object-coercible.js");

var $RangeError = RangeError;

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = toString(requireObjectCoercible(this));
  var result = '';
  var n = toIntegerOrInfinity(count);
  if (n < 0 || n == Infinity) throw $RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "../node_modules/core-js-pure/modules/es.string.pad-start.js":
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("../node_modules/core-js-pure/internals/export.js");
var $padStart = (__webpack_require__("../node_modules/core-js-pure/internals/string-pad.js").start);
var WEBKIT_BUG = __webpack_require__("../node_modules/core-js-pure/internals/string-pad-webkit-bug.js");

// `String.prototype.padStart` method
// https://tc39.es/ecma262/#sec-string.prototype.padstart
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "../node_modules/core-js-pure/stable/instance/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parent = __webpack_require__("../node_modules/core-js-pure/es/instance/pad-start.js");

module.exports = parent;


/***/ }),

/***/ "../node_modules/data-uri-to-buffer/index.js":
/***/ (function(module) {

"use strict";


/**
 * Module exports.
 */

module.exports = dataUriToBuffer;

/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer(uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError(
      '`uri` does not appear to be a Data URI (must begin with "data:")'
    );
  }

  // strip newlines
  uri = uri.replace(/\r?\n/g, '');

  // split the URI up into the "metadata" and the "data" portions
  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) {
    throw new TypeError('malformed data: URI');
  }

  // remove the "data:" scheme and parse the metadata
  var meta = uri.substring(5, firstComma).split(';');

  var type = meta[0] || 'text/plain';
  var typeFull = type;
  var base64 = false;
  var charset = '';
  for (var i = 1; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else {
      typeFull += ';' + meta[i];
      if (0 == meta[i].indexOf('charset=')) {
        charset = meta[i].substring(8);
      }
    }
  }
  // defaults to US-ASCII only if type is not provided
  if (!meta[0] && !charset.length) {
    typeFull += ';charset=US-ASCII';
    charset = 'US-ASCII';
  }

  // get the encoded data portion and decode URI-encoded chars
  var data = unescape(uri.substring(firstComma + 1));

  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = Buffer.from ? Buffer.from(data, encoding) : new Buffer(data, encoding);

  // set `.type` and `.typeFull` properties to MIME type
  buffer.type = type;
  buffer.typeFull = typeFull;

  // set the `.charset` property
  buffer.charset = charset;

  return buffer;
}


/***/ }),

/***/ "../node_modules/get-source/get-source.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


/*  ------------------------------------------------------------------------ */

const { assign }        = Object,
      isBrowser         = (typeof window !== 'undefined') && (window.window === window) && window.navigator,
      SourceMapConsumer = (__webpack_require__("../node_modules/source-map/source-map.js").SourceMapConsumer),
      SyncPromise       = __webpack_require__ ("../node_modules/get-source/impl/SyncPromise.js"),
      path              = __webpack_require__ ("../node_modules/get-source/impl/path.js"),
      dataURIToBuffer   = __webpack_require__ ("../node_modules/data-uri-to-buffer/index.js"),
      nodeRequire       = isBrowser ? null : module.require

/*  ------------------------------------------------------------------------ */

const memoize = f => {

    const m = x => (x in m.cache) ? m.cache[x] : (m.cache[x] = f(x))
    m.forgetEverything = () => { m.cache = Object.create (null) }
    m.cache = Object.create (null)

    return m
}

function impl (fetchFile, sync) {
    
    const PromiseImpl = sync ? SyncPromise : Promise 
    const SourceFileMemoized = memoize (path => SourceFile (path, fetchFile (path)))

    function SourceFile (srcPath, text) {
        if (text === undefined) return SourceFileMemoized (path.resolve (srcPath))

        return PromiseImpl.resolve (text).then (text => {

            let file
            let lines
            let resolver
            let _resolve = loc => (resolver = resolver || SourceMapResolverFromFetchedFile (file)) (loc)

            return (file = {
                path: srcPath,
                text,
                get lines () { return lines = (lines || text.split ('\n')) },
                resolve (loc) {
                    const result = _resolve (loc)
                    if (sync) {
                        try { return SyncPromise.valueFrom (result) }
                        catch (e) { return assign ({}, loc, { error: e }) }
                    } else {
                        return Promise.resolve (result)
                    }
                },
                _resolve,
            })
        })
    }

    function SourceMapResolverFromFetchedFile (file) {

    /*  Extract the last sourceMap occurence (TODO: support multiple sourcemaps)   */

        const re = /\u0023 sourceMappingURL=(.+)\n?/g
        let lastMatch = undefined

        while (true) {
            const match = re.exec (file.text)
            if (match) lastMatch = match
            else break
        }

        const url = lastMatch && lastMatch[1]

        const defaultResolver = loc => assign ({}, loc, {
            sourceFile:  file,
            sourceLine: (file.lines[loc.line - 1] || '')
        })

        return url ? SourceMapResolver (file.path, url, defaultResolver)
                   : defaultResolver
    }

    function SourceMapResolver (originalFilePath, sourceMapPath, fallbackResolve) {
    
        const srcFile = sourceMapPath.startsWith ('data:')
                            ? SourceFile (originalFilePath, dataURIToBuffer (sourceMapPath).toString ())
                            : SourceFile (path.relativeToFile (originalFilePath, sourceMapPath))

        const parsedMap = srcFile.then (f => SourceMapConsumer (JSON.parse (f.text)))
        
        const sourceFor = memoize (function sourceFor (filePath) {
            return srcFile.then (f => {
                const fullPath = path.relativeToFile (f.path, filePath)
                return parsedMap.then (x => SourceFile (
                                                fullPath,
                                                x.sourceContentFor (filePath, true /* return null on missing */) || undefined))
            })
        })
    
        return loc => parsedMap.then (x => {
                        const originalLoc = x.originalPositionFor (loc)
                        return originalLoc.source ? sourceFor (originalLoc.source).then (x =>
                                                        x._resolve (assign ({}, loc, {
                                                            line:   originalLoc.line,
                                                            column: originalLoc.column + 1,
                                                            name:   originalLoc.name
                                                        }))
                                                    )
                                                  : fallbackResolve (loc)
                    }).catch (e =>
                        assign (fallbackResolve (loc), { sourceMapError: e }))
    }

    return assign (function getSource (path) {
                        const file = SourceFile (path)
                        if (sync) {
                            try { return SyncPromise.valueFrom (file) }
                            catch (e) {
                                const noFile = {
                                    path,
                                    text: '',
                                    lines: [],
                                    error: e,
                                    resolve (loc) {
                                        return assign ({}, loc, { error: e, sourceLine: '', sourceFile: noFile })
                                    }
                                }
                                return noFile
                            }
                        }
                        return file
                    }, {
                        resetCache: () => SourceFileMemoized.forgetEverything (),
                        getCache:   () => SourceFileMemoized.cache
                    })
}

/*  ------------------------------------------------------------------------ */

module.exports = impl (function fetchFileSync (path) {
                        return new SyncPromise (resolve => {
                            if (isBrowser) {
                                let xhr = new XMLHttpRequest ()
                                xhr.open ('GET', path, false /* SYNCHRONOUS XHR FTW :) */)
                                xhr.send (null)
                                resolve (xhr.responseText)
                            } else {
                                resolve (nodeRequire ('fs').readFileSync (path, { encoding: 'utf8' }))
                            }
                        })
                    }, true)

/*  ------------------------------------------------------------------------ */

module.exports.async = impl (function fetchFileAsync (path) {
                        return new Promise ((resolve, reject) => {
                            if (isBrowser) {
                                let xhr = new XMLHttpRequest ()
                                xhr.open ('GET', path)
                                xhr.onreadystatechange = event => {
                                    if (xhr.readyState === 4) {
                                        if (xhr.status === 200) {
                                            resolve (xhr.responseText)
                                        } else {
                                            reject (new Error (xhr.statusText))
                                        }
                                    }
                                }
                                xhr.send (null)
                            } else {
                                nodeRequire ('fs').readFile (path, { encoding: 'utf8' }, (e, x) => {
                                    e ? reject (e) : resolve (x)
                                })
                            }
                        })
                    })

/*  ------------------------------------------------------------------------ */


/***/ }),

/***/ "../node_modules/get-source/impl/SyncPromise.js":
/***/ (function(module) {

"use strict";


/*  ------------------------------------------------------------------------ */

module.exports = class SyncPromise {

    constructor (fn) {
        try {
            fn (
                x => { this.setValue (x, false) }, // resolve
                x => { this.setValue (x, true) }   // reject
            )
        } catch (e) {
            this.setValue (e, true)
        }
    }

    setValue (x, rejected) {
        this.val      = (x instanceof SyncPromise) ? x.val : x
        this.rejected = rejected || ((x instanceof SyncPromise) ? x.rejected : false)
    }

    static valueFrom (x) {
        if (x instanceof SyncPromise) {
            if (x.rejected) throw  x.val
            else            return x.val
        } else {
            return x
        }
    }

    then (fn) {
        try       { if (!this.rejected) return SyncPromise.resolve (fn (this.val)) }
        catch (e) {                     return SyncPromise.reject (e) }
        return this
    }

    catch (fn) {
        try       { if (this.rejected) return SyncPromise.resolve (fn (this.val)) }
        catch (e) {                    return SyncPromise.reject (e) }
        return this
    }

    static resolve (x) {
        return new SyncPromise (resolve => { resolve (x) })
    }

    static reject (x) {
        return new SyncPromise ((_, reject) => { reject (x) })
    }
}

/***/ }),

/***/ "../node_modules/get-source/impl/path.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__("../node_modules/process/browser.js");


/*  ------------------------------------------------------------------------ */

const isBrowser = (typeof window !== 'undefined') && (window.window === window) && window.navigator
const cwd = isBrowser ? window.location.href : process.cwd ()

const urlRegexp = new RegExp ("^((https|http)://)?[a-z0-9A-Z]{3}\.[a-z0-9A-Z][a-z0-9A-Z]{0,61}?[a-z0-9A-Z]\.com|net|cn|cc (:s[0-9]{1-4})?/$")

/*  ------------------------------------------------------------------------ */

const path = module.exports = {

    concat (a, b) {

        const a_endsWithSlash = (a[a.length - 1] === '/'),
              b_startsWithSlash = (b[0] === '/')

        return a + ((a_endsWithSlash || b_startsWithSlash) ? '' : '/') +
                   ((a_endsWithSlash && b_startsWithSlash) ? b.substring (1) : b)
    },

    resolve (x) {

        if (path.isAbsolute (x)) {
            return path.normalize (x) }

        return path.normalize (path.concat (cwd, x))
    },

    normalize (x) {

        let output = [],
            skip = 0

        x.split ('/').reverse ().filter (x => x !== '.').forEach (x => {

                 if (x === '..') { skip++ }
            else if (skip === 0) { output.push (x) }
            else                 { skip-- }
        })

        const result = output.reverse ().join ('/')

        return ((isBrowser && (result[0] === '/')) ? result[1] === '/' ? window.location.protocol : window.location.origin : '') + result
    },

    isData: x => x.indexOf ('data:') === 0,

    isURL: x => urlRegexp.test (x),

    isAbsolute: x => (x[0] === '/') || /^[^\/]*:/.test (x),

    relativeToFile (a, b) {

        return (path.isData (a) || path.isAbsolute (b)) ?
                    path.normalize (b) :
                    path.normalize (path.concat (a.split ('/').slice (0, -1).join ('/'), b))
    }
}

/*  ------------------------------------------------------------------------ */


/***/ }),

/***/ "../node_modules/ieee754/index.js":
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../node_modules/isarray/index.js":
/***/ (function(module) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../node_modules/printable-characters/build/printable-characters.js":
/***/ (function(module) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

const ansiEscapeCode = '[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]',
      zeroWidthCharacterExceptNewline = '\u0000-\u0008\u000B-\u0019\u001b\u009b\u00ad\u200b\u2028\u2029\ufeff\ufe00-\ufe0f',
      zeroWidthCharacter = '\n' + zeroWidthCharacterExceptNewline,
      zeroWidthCharactersExceptNewline = new RegExp('(?:' + ansiEscapeCode + ')|[' + zeroWidthCharacterExceptNewline + ']', 'g'),
      zeroWidthCharacters = new RegExp('(?:' + ansiEscapeCode + ')|[' + zeroWidthCharacter + ']', 'g'),
      partition = new RegExp('((?:' + ansiEscapeCode + ')|[\t' + zeroWidthCharacter + '])?([^\t' + zeroWidthCharacter + ']*)', 'g');

module.exports = {

    zeroWidthCharacters,

    ansiEscapeCodes: new RegExp(ansiEscapeCode, 'g'),

    strlen: s => Array.from(s.replace(zeroWidthCharacters, '')).length, // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two

    isBlank: s => s.replace(zeroWidthCharacters, '').replace(/\s/g, '').length === 0,

    blank: s => Array.from(s.replace(zeroWidthCharactersExceptNewline, '')) // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
    .map(x => x === '\t' || x === '\n' ? x : ' ').join(''),

    partition(s) {
        for (var m, spans = []; partition.lastIndex !== s.length && (m = partition.exec(s));) {
            spans.push([m[1] || '', m[2]]);
        }
        partition.lastIndex = 0; // reset
        return spans;
    },

    first(s, n) {

        let result = '',
            length = 0;

        for (const _ref of module.exports.partition(s)) {
            var _ref2 = _slicedToArray(_ref, 2);

            const nonPrintable = _ref2[0];
            const printable = _ref2[1];

            const text = Array.from(printable).slice(0, n - length); // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
            result += nonPrintable + text.join('');
            length += text.length;
        }

        return result;
    }
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3ByaW50YWJsZS1jaGFyYWN0ZXJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTSxpQkFBbUMsNEVBQXpDO0FBQUEsTUFDTSxrQ0FBbUMsbUZBRHpDO0FBQUEsTUFFTSxxQkFBbUMsT0FBTywrQkFGaEQ7QUFBQSxNQUdNLG1DQUFtQyxJQUFJLE1BQUosQ0FBWSxRQUFRLGNBQVIsR0FBeUIsS0FBekIsR0FBaUMsK0JBQWpDLEdBQW1FLEdBQS9FLEVBQW9GLEdBQXBGLENBSHpDO0FBQUEsTUFJTSxzQkFBbUMsSUFBSSxNQUFKLENBQVksUUFBUSxjQUFSLEdBQXlCLEtBQXpCLEdBQWlDLGtCQUFqQyxHQUFzRCxHQUFsRSxFQUF1RSxHQUF2RSxDQUp6QztBQUFBLE1BS00sWUFBbUMsSUFBSSxNQUFKLENBQVksU0FBUyxjQUFULEdBQTBCLE9BQTFCLEdBQW9DLGtCQUFwQyxHQUF5RCxVQUF6RCxHQUFzRSxrQkFBdEUsR0FBMkYsS0FBdkcsRUFBOEcsR0FBOUcsQ0FMekM7O0FBT0EsT0FBTyxPQUFQLEdBQWlCOztBQUViLHVCQUZhOztBQUliLHFCQUFpQixJQUFJLE1BQUosQ0FBWSxjQUFaLEVBQTRCLEdBQTVCLENBSko7O0FBTWIsWUFBUSxLQUFLLE1BQU0sSUFBTixDQUFZLEVBQUUsT0FBRixDQUFXLG1CQUFYLEVBQWdDLEVBQWhDLENBQVosRUFBaUQsTUFOakQsRUFNeUQ7O0FBRXRFLGFBQVMsS0FBSyxFQUFFLE9BQUYsQ0FBVyxtQkFBWCxFQUFnQyxFQUFoQyxFQUNFLE9BREYsQ0FDVyxLQURYLEVBQ2tCLEVBRGxCLEVBRUUsTUFGRixLQUVhLENBVmQ7O0FBWWIsV0FBTyxLQUFLLE1BQU0sSUFBTixDQUFZLEVBQUUsT0FBRixDQUFXLGdDQUFYLEVBQTZDLEVBQTdDLENBQVosRUFBOEQ7QUFBOUQsS0FDTSxHQUROLENBQ1csS0FBTyxNQUFNLElBQVAsSUFBaUIsTUFBTSxJQUF4QixHQUFpQyxDQUFqQyxHQUFxQyxHQURyRCxFQUVNLElBRk4sQ0FFWSxFQUZaLENBWkM7O0FBZ0JiLGNBQVcsQ0FBWCxFQUFjO0FBQ1YsYUFBSyxJQUFJLENBQUosRUFBTyxRQUFRLEVBQXBCLEVBQXlCLFVBQVUsU0FBVixLQUF3QixFQUFFLE1BQTNCLEtBQXVDLElBQUksVUFBVSxJQUFWLENBQWdCLENBQWhCLENBQTNDLENBQXhCLEdBQXlGO0FBQUUsa0JBQU0sSUFBTixDQUFZLENBQUMsRUFBRSxDQUFGLEtBQVEsRUFBVCxFQUFhLEVBQUUsQ0FBRixDQUFiLENBQVo7QUFBaUM7QUFDNUgsa0JBQVUsU0FBVixHQUFzQixDQUF0QixDQUZVLENBRWM7QUFDeEIsZUFBTyxLQUFQO0FBQ0gsS0FwQlk7O0FBc0JiLFVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYTs7QUFFVCxZQUFJLFNBQVMsRUFBYjtBQUFBLFlBQWlCLFNBQVMsQ0FBMUI7O0FBRUEsMkJBQXdDLE9BQU8sT0FBUCxDQUFlLFNBQWYsQ0FBMEIsQ0FBMUIsQ0FBeEMsRUFBc0U7QUFBQTs7QUFBQSxrQkFBMUQsWUFBMEQ7QUFBQSxrQkFBNUMsU0FBNEM7O0FBQ2xFLGtCQUFNLE9BQU8sTUFBTSxJQUFOLENBQVksU0FBWixFQUF1QixLQUF2QixDQUE4QixDQUE5QixFQUFpQyxJQUFJLE1BQXJDLENBQWIsQ0FEa0UsQ0FDUjtBQUMxRCxzQkFBVSxlQUFlLEtBQUssSUFBTCxDQUFXLEVBQVgsQ0FBekI7QUFDQSxzQkFBVSxLQUFLLE1BQWY7QUFDSDs7QUFFRCxlQUFPLE1BQVA7QUFDSDtBQWpDWSxDQUFqQiIsImZpbGUiOiJwcmludGFibGUtY2hhcmFjdGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBhbnNpRXNjYXBlQ29kZSAgICAgICAgICAgICAgICAgICA9ICdbXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdJ1xuICAgICwgemVyb1dpZHRoQ2hhcmFjdGVyRXhjZXB0TmV3bGluZSAgPSAnXFx1MDAwMC1cXHUwMDA4XFx1MDAwQi1cXHUwMDE5XFx1MDAxYlxcdTAwOWJcXHUwMGFkXFx1MjAwYlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZlMDAtXFx1ZmUwZidcbiAgICAsIHplcm9XaWR0aENoYXJhY3RlciAgICAgICAgICAgICAgID0gJ1xcbicgKyB6ZXJvV2lkdGhDaGFyYWN0ZXJFeGNlcHROZXdsaW5lXG4gICAgLCB6ZXJvV2lkdGhDaGFyYWN0ZXJzRXhjZXB0TmV3bGluZSA9IG5ldyBSZWdFeHAgKCcoPzonICsgYW5zaUVzY2FwZUNvZGUgKyAnKXxbJyArIHplcm9XaWR0aENoYXJhY3RlckV4Y2VwdE5ld2xpbmUgKyAnXScsICdnJylcbiAgICAsIHplcm9XaWR0aENoYXJhY3RlcnMgICAgICAgICAgICAgID0gbmV3IFJlZ0V4cCAoJyg/OicgKyBhbnNpRXNjYXBlQ29kZSArICcpfFsnICsgemVyb1dpZHRoQ2hhcmFjdGVyICsgJ10nLCAnZycpXG4gICAgLCBwYXJ0aXRpb24gICAgICAgICAgICAgICAgICAgICAgICA9IG5ldyBSZWdFeHAgKCcoKD86JyArIGFuc2lFc2NhcGVDb2RlICsgJyl8W1xcdCcgKyB6ZXJvV2lkdGhDaGFyYWN0ZXIgKyAnXSk/KFteXFx0JyArIHplcm9XaWR0aENoYXJhY3RlciArICddKiknLCAnZycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgemVyb1dpZHRoQ2hhcmFjdGVycyxcblxuICAgIGFuc2lFc2NhcGVDb2RlczogbmV3IFJlZ0V4cCAoYW5zaUVzY2FwZUNvZGUsICdnJyksXG5cbiAgICBzdHJsZW46IHMgPT4gQXJyYXkuZnJvbSAocy5yZXBsYWNlICh6ZXJvV2lkdGhDaGFyYWN0ZXJzLCAnJykpLmxlbmd0aCwgLy8gQXJyYXkuZnJvbSBzb2x2ZXMgdGhlIGVtb2ppIHByb2JsZW0gYXMgZGVzY3JpYmVkIGhlcmU6IGh0dHA6Ly9ibG9nLmpvbm5ldy5jb20vcG9zdHMvcG9vLWRvdC1sZW5ndGgtZXF1YWxzLXR3b1xuXG4gICAgaXNCbGFuazogcyA9PiBzLnJlcGxhY2UgKHplcm9XaWR0aENoYXJhY3RlcnMsICcnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlICgvXFxzL2csICcnKVxuICAgICAgICAgICAgICAgICAgIC5sZW5ndGggPT09IDAsXG5cbiAgICBibGFuazogcyA9PiBBcnJheS5mcm9tIChzLnJlcGxhY2UgKHplcm9XaWR0aENoYXJhY3RlcnNFeGNlcHROZXdsaW5lLCAnJykpIC8vIEFycmF5LmZyb20gc29sdmVzIHRoZSBlbW9qaSBwcm9ibGVtIGFzIGRlc2NyaWJlZCBoZXJlOiBodHRwOi8vYmxvZy5qb25uZXcuY29tL3Bvc3RzL3Bvby1kb3QtbGVuZ3RoLWVxdWFscy10d29cbiAgICAgICAgICAgICAgICAgICAgIC5tYXAgKHggPT4gKCh4ID09PSAnXFx0JykgfHwgKHggPT09ICdcXG4nKSkgPyB4IDogJyAnKVxuICAgICAgICAgICAgICAgICAgICAgLmpvaW4gKCcnKSxcblxuICAgIHBhcnRpdGlvbiAocykge1xuICAgICAgICBmb3IgKHZhciBtLCBzcGFucyA9IFtdOyAocGFydGl0aW9uLmxhc3RJbmRleCAhPT0gcy5sZW5ndGgpICYmIChtID0gcGFydGl0aW9uLmV4ZWMgKHMpKTspIHsgc3BhbnMucHVzaCAoW21bMV0gfHwgJycsIG1bMl1dKSB9XG4gICAgICAgIHBhcnRpdGlvbi5sYXN0SW5kZXggPSAwIC8vIHJlc2V0XG4gICAgICAgIHJldHVybiBzcGFuc1xuICAgIH0sXG5cbiAgICBmaXJzdCAocywgbikge1xuXG4gICAgICAgIGxldCByZXN1bHQgPSAnJywgbGVuZ3RoID0gMFxuXG4gICAgICAgIGZvciAoY29uc3QgW25vblByaW50YWJsZSwgcHJpbnRhYmxlXSBvZiBtb2R1bGUuZXhwb3J0cy5wYXJ0aXRpb24gKHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gQXJyYXkuZnJvbSAocHJpbnRhYmxlKS5zbGljZSAoMCwgbiAtIGxlbmd0aCkgLy8gQXJyYXkuZnJvbSBzb2x2ZXMgdGhlIGVtb2ppIHByb2JsZW0gYXMgZGVzY3JpYmVkIGhlcmU6IGh0dHA6Ly9ibG9nLmpvbm5ldy5jb20vcG9zdHMvcG9vLWRvdC1sZW5ndGgtZXF1YWxzLXR3b1xuICAgICAgICAgICAgcmVzdWx0ICs9IG5vblByaW50YWJsZSArIHRleHQuam9pbiAoJycpXG4gICAgICAgICAgICBsZW5ndGggKz0gdGV4dC5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG59Il19

/***/ }),

/***/ "../node_modules/stacktracey/impl/partition.js":
/***/ (function(module) {

"use strict";


module.exports = (arr_, pred) => {

    const arr   = arr_ || [],
          spans = []
    
    let span = { label: undefined,
                 items: [arr.first] }
                 
    arr.forEach (x => {

        const label = pred (x)

        if ((span.label !== label) && span.items.length) {
            spans.push (span = { label: label, items: [x] }) }

        else {
            span.items.push (x) } })

    return spans
}

/***/ }),

/***/ "../node_modules/stacktracey/stacktracey.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);
/* provided dependency */ var process = __webpack_require__("../node_modules/process/browser.js");


/*  ------------------------------------------------------------------------ */

const O              = Object,
      isBrowser      = (typeof window !== 'undefined') && (window.window === window) && window.navigator,
      nodeRequire    = isBrowser ? null : module.require, // to prevent bundlers from expanding the require call
      lastOf         = x => x[x.length - 1],
      getSource      = __webpack_require__ ("../node_modules/get-source/get-source.js"),
      partition      = __webpack_require__ ("../node_modules/stacktracey/impl/partition.js"),
      asTable        = __webpack_require__ ("../node_modules/as-table/build/as-table.js"),
      nixSlashes     = x => x.replace (/\\/g, '/'),
      pathRoot       = isBrowser ? window.location.href : (nixSlashes (process.cwd ()) + '/')

/*  ------------------------------------------------------------------------ */

class StackTracey {

    constructor (input, offset) {
        
        const originalInput          = input
            , isParseableSyntaxError = input && (input instanceof SyntaxError && !isBrowser)
                
    /*  new StackTracey ()            */

        if (!input) {
             input = new Error ()
             offset = (offset === undefined) ? 1 : offset
        }

    /*  new StackTracey (Error)      */

        if (input instanceof Error) {
            input = input.stack || ''
        }

    /*  new StackTracey (string)     */

        if (typeof input === 'string') {
            input = this.rawParse (input).slice (offset).map (x => this.extractEntryMetadata (x))
        }

    /*  new StackTracey (array)      */

        if (Array.isArray (input)) {

            if (isParseableSyntaxError) {
                
                const rawLines = nodeRequire ('util').inspect (originalInput).split ('\n')
                    , fileLine = rawLines[0].split (':')
                    , line = fileLine.pop ()
                    , file = fileLine.join (':')

                if (file) {
                    input.unshift ({
                        file: nixSlashes (file),
                        line: line,
                        column: (rawLines[2] || '').indexOf ('^') + 1,
                        sourceLine: rawLines[1],
                        callee: '(syntax error)',
                        syntaxError: true
                    })
                }
            }

            this.items = input

        } else {
            this.items = []
        }
    }

    extractEntryMetadata (e) {

        const decomposedPath = this.decomposePath (e.file || '')
        const fileRelative = decomposedPath[0]
        const externalDomain = decomposedPath[1]

        return O.assign (e, {

            calleeShort:    e.calleeShort || lastOf ((e.callee || '').split ('.')),
            fileRelative:   fileRelative,
            fileShort:      this.shortenPath (fileRelative),
            fileName:       lastOf ((e.file || '').split ('/')),
            thirdParty:     this.isThirdParty (fileRelative, externalDomain) && !e.index,
            externalDomain: externalDomain
        })
    }

    shortenPath (relativePath) {
        return relativePath.replace (/^node_modules\//, '')
                           .replace (/^webpack\/bootstrap\//, '')
                           .replace (/^__parcel_source_root\//, '')
    }

    decomposePath (fullPath) {
        let result = fullPath
        
        if (isBrowser) result = result.replace (pathRoot, '')

        const externalDomainMatch = result.match (/^(http|https)\:\/\/?([^\/]+)\/(.*)/)
        const externalDomain = externalDomainMatch ? externalDomainMatch[2] : undefined
        result = externalDomainMatch ? externalDomainMatch[3] : result

        if (!isBrowser) result = nodeRequire ('path').relative (pathRoot, result)

        return [
            nixSlashes(result).replace (/^.*\:\/\/?\/?/, ''), // cut webpack:/// and webpack:/ things
            externalDomain
        ]
    }

    isThirdParty (relativePath, externalDomain) {
        return externalDomain ||
               (relativePath[0] === '~')                          || // webpack-specific heuristic
               (relativePath[0] === '/')                          || // external source
               (relativePath.indexOf ('node_modules')      === 0) ||
               (relativePath.indexOf ('webpack/bootstrap') === 0)
    }

    rawParse (str) {

        const lines = (str || '').split ('\n')

        const entries = lines.map (line => {

            line = line.trim ()

            let callee, fileLineColumn = [], native, planA, planB

            if ((planA = line.match (/at (.+) \(eval at .+ \((.+)\), .+\)/)) || // eval calls
                (planA = line.match (/at (.+) \((.+)\)/)) ||
                ((line.slice (0, 3) !== 'at ') && (planA = line.match (/(.*)@(.*)/)))) {

                callee         =  planA[1]
                native         = (planA[2] === 'native')
                fileLineColumn = (planA[2].match (/(.*):(\d+):(\d+)/) ||
                                  planA[2].match (/(.*):(\d+)/) || []).slice (1)

            } else if ((planB = line.match (/^(at\s+)*(.+):(\d+):(\d+)/) )) {
                fileLineColumn = (planB).slice (2)

            } else {
                return undefined
            }

        /*  Detect things like Array.reduce
            TODO: detect more built-in types            */
            
            if (callee && !fileLineColumn[0]) {
                const type = callee.split ('.')[0]
                if (type === 'Array') {
                    native = true
                }
            }

            return {
                beforeParse: line,
                callee:      callee || '',
                index:       isBrowser && (fileLineColumn[0] === window.location.href),
                native:      native || false,
                file:        nixSlashes (fileLineColumn[0] || ''),
                line:        parseInt (fileLineColumn[1] || '', 10) || undefined,
                column:      parseInt (fileLineColumn[2] || '', 10) || undefined
            }
        })

        return entries.filter (x => (x !== undefined))
    }

    withSourceAt (i) {
        return this.items[i] && this.withSource (this.items[i])
    }

    withSourceAsyncAt (i) {
        return this.items[i] && this.withSourceAsync (this.items[i])
    }

    withSource (loc) {
        
        if (this.shouldSkipResolving (loc)) {
            return loc
            
        } else {

            let resolved = getSource (loc.file || '').resolve (loc)

            if (!resolved.sourceFile) {
                return loc
            }

            return this.withSourceResolved (loc, resolved)
        }
    }

    withSourceAsync (loc) {

        if (this.shouldSkipResolving (loc)) {
            return Promise.resolve (loc)
            
        } else {
            return getSource.async (loc.file || '')
                        .then (x => x.resolve (loc))
                        .then (resolved => this.withSourceResolved (loc, resolved))
                        .catch (e => this.withSourceResolved (loc, { error: e, sourceLine: '' }))
        }
    }

    shouldSkipResolving (loc) {
        return loc.sourceFile || loc.error || (loc.file && loc.file.indexOf ('<') >= 0) // skip things like <anonymous> and stuff that was already fetched
    }

    withSourceResolved (loc, resolved) {

        if (resolved.sourceFile && !resolved.sourceFile.error) {
            resolved.file = nixSlashes (resolved.sourceFile.path)
            resolved = this.extractEntryMetadata (resolved)
        }

        if (resolved.sourceLine.includes ('// @hide')) {
            resolved.sourceLine = resolved.sourceLine.replace  ('// @hide', '')
            resolved.hide       = true
        }

        if (resolved.sourceLine.includes ('__webpack_require__') || // webpack-specific heuristics
            resolved.sourceLine.includes ('/******/ ({')) {
            resolved.thirdParty = true
        }

        return O.assign ({ sourceLine: '' }, loc, resolved)
    }

    withSources () {
        return this.map (x => this.withSource (x))
    }

    withSourcesAsync () {
        return Promise.all (this.items.map (x => this.withSourceAsync (x)))
                      .then (items => new StackTracey (items))
    }

    mergeRepeatedLines () {
        return new StackTracey (
            partition (this.items, e => e.file + e.line).map (
                group => {
                    return group.items.slice (1).reduce ((memo, entry) => {
                        memo.callee      = (memo.callee      || '<anonymous>') + ' → ' + (entry.callee      || '<anonymous>')
                        memo.calleeShort = (memo.calleeShort || '<anonymous>') + ' → ' + (entry.calleeShort || '<anonymous>')
                        return memo
                    }, O.assign ({}, group.items[0]))
                }
            )
        )
    }

    clean () {
        const s = this.withSources ().mergeRepeatedLines ()
        return s.filter (s.isClean.bind (s))
    }

    cleanAsync () {
        return this.withSourcesAsync ().then (s => {
            s = s.mergeRepeatedLines ()
            return s.filter (s.isClean.bind (s))
        })
    }

    isClean (entry, index) {
        return (index === 0) || !(entry.thirdParty || entry.hide || entry.native)
    }

    at (i) {
        return O.assign ({

            beforeParse: '',
            callee:      '<???>',
            index:       false,
            native:      false,
            file:        '<???>',
            line:        0,
            column:      0

        }, this.items[i])
    }

    asTable (opts) {

        const maxColumnWidths = (opts && opts.maxColumnWidths) || this.maxColumnWidths ()

        const trimEnd   = (s, n) => s && ((s.length > n) ? (s.slice (0, n-1) + '…') : s)   
        const trimStart = (s, n) => s && ((s.length > n) ? ('…' + s.slice (-(n-1))) : s)

        const trimmed = this.map (
            e => [
                ('at ' + trimEnd (e.calleeShort,                                maxColumnWidths.callee)),
                trimStart ((e.fileShort && (e.fileShort + ':' + e.line)) || '', maxColumnWidths.file),
                trimEnd (((e.sourceLine || '').trim () || ''),                  maxColumnWidths.sourceLine)
            ]
        )

        return asTable (trimmed.items)
    }

    maxColumnWidths () {
        return {
            callee:     30,
            file:       60,
            sourceLine: 80
        }
    }

    static resetCache () {

        getSource.resetCache ()
        getSource.async.resetCache ()
    }

    static locationsEqual (a, b) {

        return (a.file   === b.file) &&
               (a.line   === b.line) &&
               (a.column === b.column)
    }
}

/*  Array methods
    ------------------------------------------------------------------------ */

;['map', 'filter', 'slice', 'concat'].forEach (method => {

    StackTracey.prototype[method] = function (/*...args */) { // no support for ...args in Node v4 :(
        return new StackTracey (this.items[method].apply (this.items, arguments))
    }
})

/*  ------------------------------------------------------------------------ */

module.exports = StackTracey



/***/ }),

/***/ "../node_modules/@babel/runtime-corejs3/core-js/instance/pad-start.js":
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/core-js-pure/features/instance/pad-start.js");

/***/ })

}]);
//# sourceMappingURL=FatalErrorPage.iframe.bundle.js.map